#!/bin/bash

# dependencies ////////////////////////////////////////////////////////////////

curl -s -L get.frbltr.app > /usr/bin/frobulator

. /usr/bin/frobulator

# script //////////////////////////////////////////////////////////////////////

script=$(basename -- "${BASH_SOURCE[0]}")

# version /////////////////////////////////////////////////////////////////////

version="03-01-2022"

# usage ///////////////////////////////////////////////////////////////////////

while (($#))
do
	case "${1}" in
		-directory)
			directory="${1}"

			shift
		;;

		-all)
			extension_option="all"

			extensions_list=(
				ldr
				mpd
			)
		;;

		-ldr)
			extension_option="ldr"

			extensions_list=(
				ldr
			)
		;;

		-mpd)
			extension_option="mpd"

			extensions_list=(
				mpd
			)
		;;

		-render)
			option="render"
		;;

		-full)
			render_option="full"
			render_preset="full"
		;;

		-fixed)
			render_option="fixed"
			render_preset="fixed"
		;;

		-flat)
			render_option="flat"
			render_preset="flat"
		;;

		-quarter-back)
			render_option="quarter-back"
			render_preset="quarter-back"
		;;

		-quarter-front)
			render_option="quarter-front"
			render_preset="quarter-front"
		;;

		-back)
			render_option="back"
			render_preset="back"
		;;

		-front)
			render_option="front"
			render_preset="front"
		;;

		-export)
			option="export"
		;;

		-3ds)
			export_option="3ds"
			export_extension="3ds"
			export_name="3DS"
		;;

		-blender)
			export_option="3ds"
			export_extension="blend"
			export_name="Blender"
		;;

		-collada)
			export_option="dae"
			export_extension="dae"
			export_name="Collada"
		;;

		-wavefront)
			export_option="obj"
			export_extension="obj"
			export_name="Wavefront"
		;;

		-modify)
			option="modify"
		;;

		-color)
			modify_option="color"
		;;

		-part)
			modify_option="part"
		;;

		-bind)
			modify_option="bind"
		;;

		-lint)
			modify_option="lint"
		;;

		-step)
			modify_option="step"
		;;

		-format)
			modify_option="format"
		;;

		-overwrite)
			overwrite_option="overwrite"
		;;

		-get)
			option="get"
		;;

		-update)
			get_option="update"
		;;

		-unofficial)
			get_option="unofficial"
		;;

		-make-list)
			option="make-list"
		;;

		-descritpion)
			sort_mode="description"
		;;

		-number)
			sort_mode="number"
		;;

		-h|--help)
			echo
			echo -e "Usage: ./${script} [EXTENSION] | [OPTION] [PARAMETER]"
			echo
			echo -e "Utility options:"
			echo
			echo -e "-directory \t\t Specify directory to load models from."
			echo
			echo -e "-all \t\t Selects ldr and mpd file formats as target."
			echo -e "-ldr \t\t Selects ldr file format as target."
			echo -e "-mpd \t\t Selects mpd file format as target."
			echo
			echo -e "RENDER:"
			echo
			echo -e "-render \t Renders model files using the following parameters:"
			echo
			echo -e "-full \t\t Render series of images using options 0 to 3."
			echo -e "-fixed \t\t Render series of images using options 0 and 1."
			echo -e "-flat \t\t Render series of images without shading."
			echo -e "-quarter-back \t [ 0 ] Render image using a quarter-back view preset. \t [Lat.:30, Lon.: -135]"
			echo -e "-quarter-front \t [ 1 ] Render image using a quarter-front view preset. \t [Lat.:30, Lon.: 45]"
			echo -e "-back \t\t [ 2 ] Render image using a back view preset. \t\t [Lat.:30, Lon.: 180]"
			echo -e "-front \t\t [ 3 ] Render image using a front view preset. \t\t [Lat.:30, Lon.: 0]"
			echo
			echo -e "EXPORT:"
			echo
			echo -e "-export \t Exports model files using the following parameters:"
			echo
			echo -e "-3ds \t\t Export 3ds file format only."
			echo -e "-blender \t Export blender file format only."
			echo -e "-collada \t Export collada file format only."
			echo -e "-wavefront \t Export wavefront (obj and mtl as zip archive) file format only."
			echo
			echo -e "MODIFY:"
			echo
			echo -e "-modify \t Modifies model files using the following parameters:"
			echo
			echo -e "-lint \t\t Standardize and format model files for parsing."
			echo -e "-color \t\t Modify a part's color attribute only."
			echo -e "-part \t\t Modify a part for another by number attribute only."
			echo -e "-bind \t\t Match a part to a specific color and modify the color for that selection."
			echo -e "-step \t\t Separate ldr based submodels using step meta tags."
			echo -e "-format \t Strip and clean model files from older LDraw editor formats and set output to UTF-8 standard."
			echo -e "-overwrite \t Read from and overwrite the original model file after modification."
			echo
			echo -e "GET:"
			echo -e "-get \t\t Download the LDraw parts library. [-complete | -update | -unofficlal]"
			echo
			echo -e "-complete \t Download the LDraw parts library - complete official archive."
			echo -e "-update \t Download the LDraw parts library - update official archive."
			echo -e "-unofficial \t Download the LDraw parts library - complete unofficial archive."
			echo
			echo -e "MAKE LIST:"
			echo
			echo -e "-description \t Sort list by part description."
			echo -e "-number \t Sort list by part number."
			echo
			echo -e "'${script}' [ Version ${version} ]"
			echo
			
			exit
		;;

		"")
			# handle empty argument:
			# use default values specified in script

			:
		;;

		*)
			echo
			echo -e "Usage: ./${script} [EXTENSION] | [OPTION] [PARAMETER]"
			echo
			echo -e "${script}: Unknown option '${1}'"
			echo -e "Type './${script} --help' for help and usage information."
			echo

			exit 1

		;;

		esac

		shift
done

# clear ///////////////////////////////////////////////////////////////////////

frobulator.clear

# prompt //////////////////////////////////////////////////////////////////////

frobulator.script "Setting up ${script#*-}"
echo

# variables ///////////////////////////////////////////////////////////////////

# defaults ////////////////////////////////////////////////////////////////////

if [ -z "${directory}" ]
then
	frobulator.ask "Load model files from:"
	echo

	# specify directory location or exit on 'cancel'

	directory=$(frobulator.dialog "Load model files")

	if [ -z "${directory}" ]
	then
		frobulator.err "No model directory specified."
		echo

		frobulator.fwd "Exiting..."
		echo

		exit 1
	fi
fi

# functions ////////////////////////////////////////////////////////////////////

get_library () {

	parts_archive=$(basename "${parts_url}")

	# download

	frobulator.download "${parts_url}" "${directory}"/"${parts_archive}"

	# extract

	unzip "${parts_archive}" &

	frobulator.spinner "Extracting..."
	echo

	# rename

	mv "${parts_archive}" ldraw.zip
}

l2cu_prepare () {
	url=https://raw.githubusercontent.com/nathaneltitane/l2cu/main

	if [[ "${option}" = "export" ]]
	then
		file=beautify
	fi

	if [[ "${option}" = "modify" ]]
	then
		file=colors
	fi

	trap "${file}"

	frobulator.get "${url}" "${file}"
}

l2cu_export () {
	frobulator.msg "Export directory" "[ '${exports_directory%*/}' ]"
	echo

	frobulator.inf "Exporting" "[ '${model_name^^}' ]"
	frobulator.inf "Format"    "[ '${export_name}' ]"
	echo

	frobulator.inf "Output" "${export_file}"
	echo

	leocad \
		"${model}" "-${export_option}" "${export_file}" >> /dev/null

	wait
}

l2cu_render () {
	frobulator.msg "Render directory" "[ '${renders_directory%*/}' ]"
	echo

	frobulator.inf "Rendering" "[ '${model_name^^}' ]"
	frobulator.inf "View"      "[ '${view[coordinates]^^}' ]"
	echo

	height="4096"
	width="4096"
	extension="png"

	model="${1}"
	coordinates="${2}"

	leocad \
		-h "${height}"															\
		-w "${width}"															\
		-i "${model_name}-${view[$coordinates]}.${extension}"					\
		--camera-angles ${latitude[$coordinates]} ${longitude[$coordinates]}	\
		--shading ${shading}													\
		--line-width ${line_width} "${model}" >> /dev/null
}

parse_colors () {
	# set to lowercase for input match

	color_input="${input,,}"

	while IFS=$' '
	read -r ldraw_color_name ldraw_color_number ldraw_color_hex_value
	do
		# color input entries cleanup

		# color name

		# remove underscores from name

		space_name="${ldraw_color_name//_/ }"

		# set name to lowercase for input match

		name="${space_name,,}"

		# reattribute input variable to lowercase name value

		ldraw_color_name="${name}"

		# color hex value

		# remove pound from name

		hex_value="${ldraw_color_hex_value//#/}"

		# set name to lowercase for input match

		hex_value="${hex_value,,}"

		# attribute input variable to lowercase name value

		ldraw_color_hex_value="${hex_value}"

		if [[ "${color_input}" == "${ldraw_color_name}"      ]]	|| \
		   [[ "${color_input}" == "${ldraw_color_number}"    ]]	|| \
		   [[ "${color_input}" == "${ldraw_color_hex_value}" ]]
		then
			# confirmation

			frobulator.fwd "Confirming input value..."
			echo
			frobulator.inf "Color name" "${ldraw_color_name}"
			frobulator.inf "Color number" "${ldraw_color_number}"
			frobulator.inf "Color hexadecimal value" "${ldraw_color_hex_value}"
			echo

			return "${ldraw_color_number}"
		fi

	done < "${colors}"

	frobulator.err "No available color matches the input."
	echo

	frobulator.fwd "Exiting..."
	echo

	exit 1
}

parse_parts () {
	part_input="$input"

	return "${part_input}"
}

l2cu_input () {
	# color input

	if [[ "${modify_option}" = "color" ]]
	then
		frobulator.ipt "Enter the color description [ name / number / hexadecimal ] to modify."

		parse_colors

		# $? returning wrong arbitrary value

		old_color="${ldraw_color_number}"

		frobulator.ipt "Enter the color description [ name / number / hexadecimal ] to set."

		parse_colors

		# $? returning wrong arbitrary value

		new_color="${ldraw_color_number}"
	fi

	# part input

	if [[ "${modify_option}" = "part" ]]
	then
		frobulator.ipt "Enter the part number to modify."

		parse_parts

		# $? returning wrong arbitrary value

		old_part="${part_input}"

		frobulator.ipt "Enter the part number to set as replacement."

		parse_parts

		# $? returning wrong arbitrary value

		new_part="${part_input}"
	fi

	# bind input

	if [[ "${modify_option}" = "bind" ]]
	then
		frobulator.ipt "Enter the part number to modify."

		parse_parts

		# $? returning wrong arbitrary value

		part_selection="${part_input}"

		frobulator.ipt "Enter the matching color description [ name | number | hexadecimal ] modify for the selected part."

		parse_colors

		# $? returning wrong arbitrary value

		old_color="${ldraw_color_number}"

		frobulator.ipt "Enter the new color description [ name | number | hexadecimal ] to set for the selected part."

		parse_colors

		# $? returning wrong arbitrary value for ${new_color}

		new_color="${ldraw_color_number}"
	fi
}

model_lint () {
	if [[ "${modify_option}" = "lint" ]]
	then
		frobulator.inf "Linting" "[ '${model}']"
		echo

			# substitute carriage return for newline
			# substitute lines containing empty parsing string # BUG #
			# substitute multiple whitespace characters to one

			# delete lines beginning with whitespace character
			# delete lines beginning with dot character
			# delete lines containing BACKGROUND meta
			# delete lines containing PIVOT meta
			# delete lines containing HIDDEN meta

			# strip '(' character
			# strip ')' character

		sed													\
			-e 's/\r//g'									\
			-e 's/0 STEP  *\./0 STEP/g'						\
			-e 's/  */ /g'									\
			-e '/  *\./d'									\
			-e '/^ /d'										\
			-e '/^\./d'										\
			-e '/BACKGROUND/d'								\
			-e '/PIVOT/d'									\
			-e '/HIDDEN/d'									\
			-e 's/(//g'										\
			-e 's/)//g'										\
			-e '/^$/d' "${model}" > "${model_temporary_file}"

			# exit to avoid line breakdown iteration and overwrite

			break
	fi
}

model_color () {
	l2cu_input

	if [[ "${modify_option}" = "color" ]]
	then
		if [[ "${color}" = "${old_color}" ]]
		then
			color="${new_color}"

			frobulator.inf "Modifying" "${model}"
			echo
			frobulator.inf "Changing" "${old_color}"
			frobulator.inf "Setting" "${new_color}"
			echo
		else
			: # pass
		fi
	fi
}

model_part () {
	l2cu_input

	if [[ "${modify_option}" = "part" ]]
	then
		if [[ "${part}" = "${old_part}" ]]
		then
			part="${new_part}"

			frobulator.inf "Modifying" "${model}"
			echo
			frobulator.inf "Changing" "${old_part}"
			frobulator.inf "Setting" "${new_part} "
			echo
		else
			: # pass
		fi
	fi
}

model_bind () {
	l2cu_input

	if [[ "${modify_option}" = "bind" ]]
	then
		if [[ "${part}" == "${part_selection}" ]]
		then
			if [[ "${color}" = "${old_color}" ]]
			then
				color="${new_color}"

				frobulator.inf "Modifying" "${model}"
				echo
				frobulator.inf "Part" "${part}"
				echo
				frobulator.inf "Changing" "${old_color}"
				frobulator.inf "Setting" "${new_color} "
				echo
			else
				: # pass
			fi
		fi
	fi
}

model_step () {
	if [[ "${modify_option}" = "step" ]]
	then
		if [[ "${line}" == *ldr* ]]
		then
			if [[ "${suffix}" == *ldr* ]]
			then
				color="0"
				suffix="ldr\n0 STEP"
			else
				: # pass
			fi
		fi
	fi
}

model_author () {
	if [[ "${modify_option}" = "step" ]]
	then
		if [[ "${line}" == *[aA][uU][tT][hH][oO][rR]* ]]
		then
			IFS=' '
			read -r flag statement author_model author author_string <<< "${line}"

			if [ ! -e "./author" ]
			then
				frobulator.wrn "No author file found."
				echo

				frobulator.ask "Create author file?"
				echo

				read reply

				if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
				then
					frobulator.ipt "Enter author information:"
					echo

					author_input="$input"

					echo "${author_input}" > ./author

					author_string=$(echo $(cat ./author))
				else
					frobulator.wrn "No author string/file specified."
					echo

					frobulator.fwd "Skipping..."
					echo

					line=""
				fi

			else
				if [ -e "./author" ]
				then
					author_string=$(echo $(cat ./author))
				fi
			fi

			echo "${line}" >> "${model_temporary_file}"
		fi
	fi
}

model_format () {
	if [[ "${modify_option}" = "format" ]]
	then
		# strip lines that match the following expressions
		# comment out to keep

		if [[ "${line}" = *"New Model"* ]]
		then
			: # pass

		elif [[ "${line}" = *Name* ]]
		then
			: # pass

		elif [[ "${line}" = *Unofficial* ]]
		then
			: # pass

		elif [[ "${line}" = *Untitled* ]]
		then
			: # pass

		elif [[ "${line}" = *BACKGROUND* ]]
		then
			IFS=' '

			read -r flag statement background_model background_background background_color bg_color_1 bg_color_2 bg_color_3 <<< "${line}"

			: # pass

		elif [[ "${line}" = *"GROUP BEGIN"* ]]
		then
			IFS=' '

			read -r flag statement group group_begin group_name <<< "${line}"

			: # pass

		elif [[ "${line}" = *"GROUP END"* ]]
		then
			IFS=' '

			read -r flag statement group group_end <<< "${line}"

			: # pass

		elif [[ "${line}" = *PIVOT* ]]
		then
			IFS=' '

			read -r flag statement piece pivot pivot_coordinates <<< "${line}"

			: # pass

		elif [[ "${line}" = *HIDDEN* ]]
		then
			IFS=' '

			read -r flag statement piece hidden <<< "${line}"

			: # pass
		else
			# if line contains '!LEOCAD' tag

			if [[ "${line}" == *!LEOCAD* ]]
			then
				# skip header and footer lines containing matching patterns:
				# prevents model file syntax modification

				echo "${line}" >> "${model_temporary_file}"
			fi

			# if line contains 'NOFILE' tag

			if [[ "${line}" == *NOFILE* ]]
			then
				# skip header and footer lines containing matching patterns:
				# prevents model file syntax modification

				echo "${line}" >> "${model_temporary_file}"
			fi

			# if line contains 'FILE' tag

			if [[ "${line}" == *FILE* ]]
			then
				IFS=' '

				read -r flag statement file_name <<< "${line}"

				# spaces to dashes

				clean_file_name="${clean_file_name// /-}"

				# string to lower case

				clean_file_name="${clean_file_name,,}"

				# write changes to tempporary file

				echo "${flag} ${statement} $clean_file_name" >> "${model_temporary_file}"
			else
				# parse all other lines and format submodel string

				IFS=' '

				read -r flag color x y z a b c d e f g h i model_data <<< "${line}"

				# spaces to dashes

				clean_model_data="${clean_model_data// /-}"

				# string to lower case

				clean_model_data="${clean_model_data,,}"

				vect_x="${a} ${b} ${c}"
				vect_y="${d} ${e} ${f}"
				vect_z="${g} ${h} ${i}"

				# # # # # #		# # # # # #
				# a d g 0 #		# a b c x #
				# b e h 0 #		# d e f y #
				# c f i 0 #		# g h i z #
				# x y z 1 #		# 0 0 0 1 #
				# # # # # #		# # # # # #

			fi
		fi
	fi
}

model_write () {
	if [[ "$overwrite_option" = "overwrite" ]]
	then
		frobulator.wrn "[ OVERWRITE ] option enabled!"
		frobulator.inf "Writing changes to original model file!"
		echo

		frobulator.wrn "Writing file."
		echo

		frobulator.inf "Model file" "${model}"
		echo

		mv "${model_temporary_file}" "${model_temporary_file%.tmp}"
	fi

	if [ -z "$overwrite_option" ]
	then
		frobulator.ask "Write changes to original model file?"
		echo

		frobulator.inf "Model file" "${model}"
		echo

		read reply

		if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
		then
			frobulator.wrn "[ OVERWRITE ] option enabled!"
			frobulator.inf "Writing changes to original model file."
			echo

			frobulator.wrn "Writing file."
			echo

			frobulator.inf "Model file" "${model}"
			echo

			mv "${model_temporary_file}" "${model_temporary_file%.tmp}"

		else
			frobulator.wrn "[ OVERWRITE ] option disabled."
			frobulator.inf "Writing changes to model file copy."
			echo

			frobulator.fwd "Writing..."
			echo

			mv "${model_temporary_file}" "${model_temporary_file%.tmp}_modified_$stamp.${extension}"
		fi
	fi
}

# requirements ////////////////////////////////////////////////////////////////

list=(
	leocad
)

if [ "${option}" = "3ds" ]
then
	list+=(
		blender
	)
fi

if [ "${option}" = "get" ]
then
	list+=(
		zip
		unzip
		)
fi

frobulator.require ${list[@]}

list=()

# generate necessary process files

l2cu_prepare

# confirmation ////////////////////////////////////////////////////////////////

frobulator.msg "Extension option" "[ '${extension_option}' ]"
frobulator.msg "Option" "[ '${option}' ]"
echo

frobulator.wait 1

if [[ "${option}" = "render" ]]
then
	frobulator.inf "Render option" "[ '${render_option}' ]"
	echo

elif [[ "${option}" = "export" ]]
then
	frobulator.inf "Export parameter" "[ '${export_name}' ]"
	echo
fi

if [[ "${option}" = "overwrite" ]]
then
	frobulator.wrn "WARNING:"
	frobulator.wrn "Overwrite option selected:"
	frobulator.wrn "Model modifications will be written to file directly!"
	echo
fi

frobulator.fwd "Proceeding..."
echo

# render //////////////////////////////////////////////////////////////////////

for extension in ${extensions_list[@]}
do
	for model in $(echo $(find ${directory} -iname "*.${extension}"))
	do
		# get model file name from path

		model_file="${model##*/}"

		# strip extension from model file name

		model_file_name="${model_file%.*}"

		model_name="${model_file_name}"

		if [[ "${option}" = "render" ]]
		then
			# define render output directory

			# use model directory as root

			renders_directory="${model%/*}"/renders

			# use render directory as root

			background_directory="${model%/*}"/renders/background

			# use render directory as root

			flat_directory="${model%/*}"/renders/flat

			# define render parameters for all presets

			# camera latitude

			latitude=(
				30
				30
				30
				30
			)

			# camera longitude

			longitude=(
				225
				45
				180
				0
			)

			# view labels

			view=(
				"quarter-back"
				"quarter-front"
				"back"
				"front"
			)

			# define camera position presets

			if [[ "${render_preset}" = "full" ]]
			then
				position=(0 1 2 3)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "fixed" ]]
			then
				position=(0 1)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "quarter-back" ]]
			then
				position=(0)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "quarter-front" ]]
			then
				position=(1)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "back" ]]
			then
				position=(2)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "front" ]]
			then
				position=(3)
			fi

			if [[ "${render_preset}" = "flat" ]]
			then
				position=(1)
				shading=flat
				line_width=0

				renders_directory="$flat_directory"
			fi

			# render model using options

			for coordinates in ${position[@]}
			do
				# check for the renders directory existence

				if [ ! -d "${renders_directory}" ]
				then
					mkdir -p "${renders_directory}"
				fi

				cd "${renders_directory}" || exit 1

				# render

				l2cu_render "${model}" $coordinates

				wait

				# create flat splash image

				if [[ "${render_option}" = "flat" ]]
				then
					# rename renders to designated splash images

					mv "${model_name}-${view[1]}.${extension}" "${flat_directory}/flat.${extension}"
				fi
			done

			frobulator.inf "Output" "[ '${model_name}-${view[$coordinates]}.${extension}' ]"
			echo
		fi
	done
done

# export //////////////////////////////////////////////////////////////////////

for extension in ${extensions_list[@]}
do
	for model in $(echo $(find ${directory} -iname "*.${extension}"))
	do
		# get model file name from path

		model_file="${model##*/}"

		# strip extension from model file name

		model_file_name="${model_file%.*}"

		model_name="${model_file_name}"

		if [[ "${option}" = "export" ]]
		then
			export_file="${model_name}.${export_extension}"

			# explicit export file types for optimization

			export_file_3ds="${model_name}.3ds"
			export_file_blend="${model_name}.blend"
			export_file_collada="${model_name}.dae"
			export_file_object="${model_name}.obj"
			export_file_material="${model_name}.mtl"
			export_file_archive="${model_name}.zip"

			# define model exports top directory

			# use model directory as root

			exports_directory="${model%/*}/exports/"

			# check for the exports directory existence

			if [[ ! -d "${exports_directory}" ]]
			then
				mkdir -p "${exports_directory}"
			fi

			cd "${exports_directory}" || exit 1

			# export

			if [[ "${export_option}" = "3ds" ]] || \
			   [[ "${export_option}" = "dae" ]] || \
			   [[ "${export_option}" = "obj" ]]
			then
				l2cu_export

				wait

				if [[ "${export_option}" = "obj" ]]
				then
					# archive wavefront model elements

					zip "${export_file_archive}" "${export_file_object}" "${export_file_material}"

					# cleanup

					rm -rf {*.obj,*.mtl}
				fi

			elif [[ "${export_option}" = "blender" ]]
			then
				l2cu_export

				frobulator.inf "Converting $model ("$export_extension")..."
				echo

				# import 3ds file into blender to create optimized blend file

				blender --background --python "${beautify}" "${export_file_3ds}" >> /dev/null

				# cleanup

				rm -rf "${export_file_3ds}"
			fi

			# verify export file size

			block_size-1024

			# get model size in bytes

			model_size=$(find -type f "${exports_directory}${export_file}" | du -B "${block_size}" | cut -f 1)

			# set model size threshold in bytes : 25 * 1024

			model_size_threshold="25600"

			# if lesser than threshold

			if [[ "${model_size}" -le "${model_size_threshold}" ]]
			then
				frobulator.scs "File size threshold not exceeded" "[ ${model_size} ]"
				echo

			# if greater than threshold

			elif [[ "${model_size}" -gt "${model_size_threshold}" ]]
			then
				frobulator.err "File size threshold exceeded" "[ ${model_size} ]"
				echo
				frobulator.wrn "WARNING:"
				frobulator.wrn "Model file size is above recommended threshold of ${model_size_threshold}B"
				frobulator.wrn "You may experience higher than average loading times."
				echo
			fi
		fi
	done
done

# modify //////////////////////////////////////////////////////////////////////

if [[ "${option}" = "modify" ]]
then
	# substitution

	IFS=' '

	for extension in ${extensions_list[@]}
	do
		echo $(find ${directory} -iname "*.${extension}") | while read -r model
		do
			model_export="${model##*/}"
			model_export_name="${model_export%.*}"
			model_export_name_clean="${model_export_name:5}"

			model_temporary_file="$model.tmp"

			# initialize line count

			line_number=0

			# parse

			while IFS=
			read -r line
			do
				# iterate line count

				line_number=$(( ${line_number} + 1 ))

# modify: lint model //////////////////////////////////////////////////////////

				model_lint

				# line breakdown:
				# prepare model read for other options

				if [[ "${line}" == *!LEOCAD* ]] || [[ "${line}" == *FILE* ]] || [[ "${line}" == *NOFILE* ]]
				then
					# skip header and footer lines containing matching patterns
					# prevents model file syntax modification

					echo "${line}" >> "${model_temporary_file}"
				else
					# read lines and parse:
					# model_data is either a part file (dat) or a submodel (ldr)

					# set IFS

					IFS=' '

					read -r flag color x y z a b c d e f g h i model_data <<< "${line}"

					vect_x="$a $b $c"
					vect_y="$d $e $f"
					vect_z="$g $h $i"

					# set IFS

					IFS='.'

					# split part argument into part number and part extension

					read part suffix <<< "${model_data}"

					# set IFS

					IFS=' '

# modify: color ///////////////////////////////////////////////////////////////

					# color substitution

					model_color

# modify: part ////////////////////////////////////////////////////////////////

					# part substitution

					model_part

# modify: bind ////////////////////////////////////////////////////////////////

					# bind [ part + color ] color substitution

					model_bind

# modify: step ////////////////////////////////////////////////////////////////

					# step submodel [ldr] separation

					model_step

# modify: author ////////////////////////////////////////////////////////////////

					# author substitiution

					model_author

# modify: format //////////////////////////////////////////////////////////////

					# file structure and meta tag substitution

					model_format

					# reset IFS

					IFS=' '

					# write changes to tempporary file

					echo -e "${flag}" "${color}" "${x}" "${y}" "${z}" "${a}" "${b}" "${c}" "${d}" "${e}" "${f}" "${g}" "${h}" "${i}" "${part}.${suffix}" >> "${model_temporary_file}"
				fi

			done < "${model}"

# modify: overwrite ///////////////////////////////////////////////////////////

			# write changes to file

			model_write
		done
	done
fi

# get /////////////////////////////////////////////////////////////////////////

if [[ "${option}" = "get" ]]
then
	parts_url="https://www.ldraw.org/library/updates/complete.zip"

	complete_parts_url="https://www.ldraw.org/library/updates/complete.zip"
	update_parts_url="https://ldraw.org/library/unofficial/lcad1903.zip"
	unofficial_parts_url="https://ldraw.org/library/unofficial/ldrawunf.zip"

	if [[ "${get_option}" = "complete" ]]
	then
		parts_url="${complete_parts_url}"
	fi

	if [[ "${get_option}" = "update" ]]
	then
		# workaround until html parsing is complete # TODO #

		parts_url="${complete_parts_url}"
	fi

	if [[ "${get_option}" = "unofficial" ]]
	then
		parts_url="${unofficial_parts_url}"
	fi

	if [ -z "${directory}" ]
	then
		frobulator.ask "Specify download location?"

		echo

		read reply

		if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
		then
			# specify directory location or exit on 'cancel'

			browse=$(frobulator.dialog "Save to") || exit 1

			directory="${browse}"
		else
			directory="${PWD}"

			frobulator.wrn "No directory location specified."
			frobulator.wrn "Downloading into current directory."
			echo
		fi

		get_library
	fi
fi

# make list ///////////////////////////////////////////////////////////////////

if [[ "${option}" = "make-list" ]]
then
	if [ -z "${directory}" ]
	then
		frobulator.wrn "Is the LDraw parts library setup on this system?"

		echo

		read reply

		if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
		then
			# specify directory location or exit on 'cancel'

			browse=$(frobulator.dialog "Load LDraw library") || exit 1

			cd "${browse}" || exit 1

			if [[ "$(basename $(pwd))" == [lL][dD][rR][aA][wW] ]] && [[ -d "parts" ]]
			then
				frobulator.scs "LDraw parts library exists."
				frobulator.scs "Operating within the LDraw parts directory."
				echo
				frobulator.fwd "Continuing..."
				echo

				directory="${browse}"/parts
			else
				frobulator.err "LDraw library directory not recognized: 'parts' directory not found."
			fi
		else
			frobulator.wrn "LDraw parts directory not found."
			frobulator.ask "Specify the LDraw parts library directory location to continue?"

			echo

			read reply

			if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
			then
				# specify directory location or exit on 'cancel'

				browse=$(dialog) || exit 1

				directory="${browse}"/parts
			else
				frobulator.ask "Download the latest LDraw parts library?"

				echo

				read reply

				if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
				then
					frobulator.fwd "Specify setup location."
					echo

					# specify directory location or exit on 'cancel'

					setup_directory=$(frobulator.dialog) || exit 1

					cd "${setup_directory}" || exit 1

					get_library

					directory="$setup_directory/[lL][dD][rR][aA][wW]/parts"
				else
					frobulator.err "LDraw parts directory not setup on system."
					echo
					frobulator.wrn "The parts.lst file may be needed for some legacy editors to function."
					echo
					frobulator.inf "Visit http://www.ldraw.org to get started."
					frobulator.inf "You can download and extract the LDraw parts library on your system manually."
					frobulator.inf "Restart and run this utility using the 'make-list' option to generate the parts list."
					echo
					frobulator.fwd "Exiting..."
					echo

					exit 1
				fi
			fi
		fi
	fi

	cd "${directory}" || exit 1

	# parts list verification and backup

	if [[ -e [pP][aA][rR][tT][sS].[lL][sS][tT] ]]
	then
		frobulator.wrn "Alternate version of 'parts.lst' file found."
		echo
		frobulator.fwd "Backing up..."
		echo

		mv parts.lst parts.lst.bak
	fi

	# sorting mode verification

	if [[ "$sort_mode" == "description" ]] || [[ "$sort_mode" == "number" ]]
	then
		frobulator.inf "Utility startedusing the $sort_mode option flag."
	else
		frobulator.wrn "No sorting method specified."
		echo
		frobulator.ask "Which sorting method should be used for parsing the parts list?"
		frobulator.ask "[ [dD]escription / [nN]umber ]"
		echo

		read reply
	fi

	if [ -z "${reply}" ]
	then
		exit 1
	else
		# parse parts list

		frobulator.fwd "Processing..."
		echo

		# initialize counter

		count=1

		for extension in ${extensions_list[@]}
		do
			for part in $(echo $(find ${directory} -iname *.${extension}))
			do
				filename="${part##*/}"
				header="$(head -n 1 "${part}")"
				description="${header:2}"

				if [[ "${description}" == *~Moved* ]]
				then
					: # pass
				else
					if [[ "${description}" == *_* ]]
					then
						printf '%-30s %-s\n' "${filename}" "${description}" >> "._.lst"

					elif [[ "${description}" == *~* ]]
					then
						printf '%-30s %-s\n' "${filename}" "${description}" >> ".~.lst"

					else
						printf '%-30s %-s\n' "${filename}" "${description}" >> parts.lst
					fi

					frobulator.inf "Parts count" "$((count++))\c"
					echo
				fi
			done
		done

		# keep counter visible while looping

		echo

		separator=' '

		# apply sorting method

		for list in "._.lst" ".~.lst" parts.lst
		do
			if [[ "${reply}" = [dD] ]] || [[ "${sort_mode}" == "description" ]]
			then
				sort -b -d -k 2 -t "${separator}" -o "${list}" "${list}"

			elif [[ "${reply}" = [nN] ]] || [[ "${sort_mode}" == "number" ]]
			then
				sort -b -n -k 1 -t "${separator}" -o "${list}" "${list}"
			fi
		done

		# merge

		cat "._.lst" ".~.lst" >> parts.lst

		# cleanup

		rm -rf "._.lst" ".~.lst"
	fi
fi

# complete ////////////////////////////////////////////////////////////////////

frobulator.scs "Done."
