#!/bin/bash

# dependencies ////////////////////////////////////////////////////////////////

curl -s -L get.frbltr.app > /usr/bin/frobulator

. /usr/bin/frobulator

# script //////////////////////////////////////////////////////////////////////

script=$(basename -- "${BASH_SOURCE[0]}")

# version /////////////////////////////////////////////////////////////////////

version="03-01-2022"

# usage ///////////////////////////////////////////////////////////////////////

while (($#))
do
	case "${1}" in
		-directory)
			directory="${2}"

			shift
		;;

		-all)
			extension_option="all"

			extensions_list=(
				ldr
				mpd
			)
		;;

		-ldr)
			extension_option="ldr"

			extensions_list=(
				ldr
			)
		;;

		-mpd)
			extension_option="mpd"

			extensions_list=(
				mpd
			)
		;;

		-render)
			option="render"
		;;

			full)
				render_option="full"
				render_preset="full"
			;;

			fixed)
				render_option="fixed"
				render_preset="fixed"
			;;

			flat)
				render_option="flat"
				render_preset="flat"
			;;

			quarter-back)
				render_option="quarter-back"
				render_preset="quarter-back"
			;;

			quarter-front)
				render_option="quarter-front"
				render_preset="quarter-front"
			;;

			back)
				render_option="back"
				render_preset="back"
			;;

			front)
				render_option="front"
				render_preset="front"
			;;

		-export)
			option="export"
		;;

			3dstudio)
				export_option="3dstudio"
				export_extension="3ds"
				export_name="3DS"
			;;

			collada)
				export_option="collada"
				export_extension="dae"
				export_name="Collada"
			;;

			blender)
				export_option="3dstudio"
				export_extension="blend"
				export_name="Blender"
			;;

			wavefront)
				export_option="wavefront"
				export_extension="obj"
				export_name="Wavefront"
			;;

		-modify)
			option="modify"
		;;

			color)
				modify_option="color"
			;;

			part)
				modify_option="part"
			;;

			bind)
				modify_option="bind"
			;;

			lint)
				modify_option="lint"
			;;

			step)
				modify_option="step"
			;;

		-overwrite)
			overwrite_option="overwrite"
		;;

		-get)
			option="get"
		;;

			complete)
				get_option="complete"
			;;

			update)
				get_option="update"
			;;

			unofficial)
				get_option="unofficial"
			;;

		-list)
			option="make-list"
		;;

			descritpion)
				sort_mode="description"
			;;

			number)
				sort_mode="number"
			;;

		-h|--help)
			echo
			echo -e "Usage: ./${script} [EXTENSION] | [OPTION] [PARAMETER]"
			echo
			echo -e "Utility options:"
			echo
			echo -e "-directory        Specify directory to load models from."
			echo
			echo -e "-all              Selects ldr and mpd file formats as target."
			echo -e "-ldr              Selects ldr file format as target."
			echo -e "-mpd              Selects mpd file format as target."
			echo
			echo -e "RENDER:"
			echo
			echo -e "-render           Renders model files using the following parameters:"
			echo
			echo -e "full              Render series of images using options 0 to 3."
			echo -e "fixed             Render series of images using options 0 and 1."
			echo -e "flat              Render series of images without shading."
			echo -e "quarter-back      Render image using a quarter-back view preset.     [ 0 ] [ Lat.:30, Lon.: -135]"
			echo -e "quarter-front     Render image using a quarter-front view preset.    [ 1 ] [ Lat.:30, Lon.: 45 ]"
			echo -e "back              Render image using a back view preset.             [ 2 ] [ Lat.:30, Lon.: 180 ]"
			echo -e "front             Render image using a front view preset.            [ 3 ] [ Lat.:30, Lon.: 0 ]"
			echo
			echo -e "EXPORT:"
			echo
			echo -e "-export           Exports model files using the following parameters:"
			echo
			echo -e "3dstudio          Export 3dstudio file format.                            [ 3ds]"
			echo -e "collada           Export collada file format.                             [ dae ]"
			echo -e "blender           Optimize 3dstudio and export to blender file format.    [ 3ds > blend ]"
			echo -e "wavefront         Generate wavefront files and archive.                   [ obj + mtl > zip ]"
			echo
			echo -e "MODIFY:"
			echo
			echo -e "-modify           Modifies model files using the following parameters:"
			echo
			echo -e "lint              Standardize and format model files for parsing."
			echo -e "color             Modify a part's color attribute only."
			echo -e "part              Modify a part for another by number attribute only."
			echo -e "bind              Match a part to a specific color and modify the color for that selection."
			echo -e "step              Separate ldr based submodels using step meta tags."
			echo -e "overwrite         Overwrite the original model file after modification."
			echo
			echo -e "GET:"
			echo -e "-get              Download the LDraw parts library. [-complete | -update | -unofficlal]"
			echo
			echo -e "complete         Download the LDraw parts library - complete official archive."
			echo -e "update           Download the LDraw parts library - update official archive."
			echo -e "unofficial       Download the LDraw parts library - complete unofficial archive."
			echo
			echo -e "LIST:"
			echo
			echo -e "-list              Generate the LDraw parts list for use with legacy editors."
			echo
			echo -e "description      Sort list by part description."
			echo -e "number           Sort list by part number."
			echo
			echo -e "'${script}'       [ Version ${version} ]"
			echo
			
			exit
		;;

		"")
			# handle empty argument:
			# use default values specified in script

			:
		;;

		*)
			echo
			echo -e "Usage: ./${script} [EXTENSION] | [OPTION] [PARAMETER]"
			echo
			echo -e "${script}: Unknown option '${1}'"
			echo -e "Type './${script} --help' for help and usage information."
			echo

			exit 1

		;;

		esac

		shift
done

# clear ///////////////////////////////////////////////////////////////////////

frobulator.clear

# prompt //////////////////////////////////////////////////////////////////////

frobulator.script "Setting up ${script#*-}"
echo

# variables ///////////////////////////////////////////////////////////////////

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# defaults ////////////////////////////////////////////////////////////////////

if [ -z "${directory}" ]
then
	frobulator.ask "Load model files from:"
	echo

	# specify directory location or exit on 'cancel'

	directory=$(frobulator.dialog "Load model files")

	if [ -z "${directory}" ]
	then
		frobulator.err "No model directory specified."
		echo

		frobulator.fwd "Exiting..."
		echo

		exit 1
	fi
fi

# functions ////////////////////////////////////////////////////////////////////

get_library () {
	parts_archive=$(basename "${parts_url}")

	# download

	frobulator.download "${parts_url}" "${directory}"/"${parts_archive}"

	# extract

	unzip "${parts_archive}" &

	frobulator.spinner "Extracting..."
	echo

	# rename

	mv "${parts_archive}" ldraw.zip
}

l2cu_prepare () {
	if [[ "${option}" = "export" ]]
	then
		optimize=$(mktemp /tmp/optimize.XXXXXX)

		trap 'rm -rf "${optimize}"' EXIT

		# push blender conversion script to temporary file

		cat <<- 'OPTIMIZE' > "${optimize}"
		#!/usr/bin/env python3

		import os
		import bpy
		from sys import argv

		context = bpy.context

		# arguments #
		# [blender, --background, --python, script, 3ds]
		# model_path = argv[4]

		# prepare scene #

		for obj in context.scene.objects:
			obj.select = True

		bpy.ops.object.delete()

		# import #

		export_model = argv[4]
		bpy.ops.import_scene.autodesk_3ds(filepath=export_model)

		# join objects #

		context.scene.objects.active = context.selected_objects[0]
		bpy.ops.object.join()

		# normalize transforms #
		bpy.ops.object.transform_apply(
			location = True,
			rotation = True,
			scale = True
		)

		# add smooth shade and edge split modifiers #

		bpy.ops.object.shade_smooth()
		bpy.ops.object.modifier_add(
			type = "EDGE_SPLIT"
		)

		# remove doubles #

		bpy.ops.object.editmode_toggle()
		bpy.ops.mesh.remove_doubles()

		# remove loose vertices #

		bpy.ops.mesh.select_loose()
		bpy.ops.mesh.delete(type='VERT')

		bpy.ops.mesh.normals_make_consistent(
			inside = False
		)
		bpy.ops.object.editmode_toggle()

		# save #

		blend_file = export_model.replace(".3ds",".blend")
		bpy.ops.wm.save_as_mainfile(
			filepath = blend_file,
			compress = True
		)

		# print output #

		print("saved as:", blend_file)
		bpy.ops.wm.quit_blender()
		OPTIMIZE
	fi

	if [[ "${option}" = "modify" ]]
	then
		colors=$(mktemp /tmp/ldraw-colors.XXXXXX)

		trap 'rm -rf "${colors}"' EXIT

		cat <<- 'COLORS' > "${colors}"
		# ldraw colors

		Black                                   0          #05131D
		Blue                                    1          #0055BF
		Green                                   2          #257A3E
		Dark_Turquoise                          3          #00838F
		Red                                     4          #C91A09
		Dark_Pink                               5          #C870A0
		Brown                                   6          #583927
		Light_Gray                              7          #9BA19D
		Dark_Gray                               8          #6D6E5C
		Light_Blue                              9          #B4D2E3
		Bright_Green                            10         #4B9F4A
		Light_Turquoise                         11         #55A5AF
		Salmon                                  12         #F2705E
		Pink                                    13         #FC97AC
		Yellow                                  14         #F2CD37
		White                                   15         #FFFFFF
		Light_Green                             17         #C2DAB8
		Light_Yellow                            18         #FBE696
		Tan                                     19         #E4CD9E
		Light_Violet                            20         #C9CAE2
		Purple                                  22         #81007B
		Dark_Blue_Violet                        23         #2032B0
		Orange                                  25         #FE8A18
		Magenta                                 26         #923978
		Lime                                    27         #BBE90B
		Dark_Tan                                28         #958A73
		Bright_Pink                             29         #E4ADC8
		Medium_Lavender                         30         #AC78BA
		Lavender                                31         #E1D5ED
		Very_Light_Orange                       68         #F3CF9B
		Light_Purple                            69         #CD6298
		Reddish_Brown                           70         #582A12
		Light_Bluish_Gray                       71         #A0A5A9
		Dark_Bluish_Gray                        72         #6C6E68
		Medium_Blue                             73         #5C9DD1
		Medium_Green                            74         #73DCA1
		Light_Pink                              77         #FECCCF
		Light_Flesh                             78         #F6D7B3
		Medium_Dark_Flesh                       84         #CC702A
		Dark_Purple                             85         #3F3691
		Dark_Flesh                              86         #7C503A
		Blue_Violet                             89         #4C61DB
		Flesh                                   92         #D09168
		Light_Salmon                            100        #FEBABD
		Violet                                  110        #4354A3
		Medium_Violet                           112        #6874CA
		Medium_Lime                             115        #C7D23C
		Aqua                                    118        #B3D7D1
		Light_Lime                              120        #D9E4A7
		Light_Orange                            125        #F9BA61
		Very_Light_Bluish_Gray                  151        #E6E3E0
		Bright_Light_Orange                     191        #F8BB3D
		Bright_Light_Blue                       212        #86C1E1
		Rust                                    216        #B31004
		Bright_Light_Yellow                     226        #FFF03A
		Sky_Blue                                232        #56BED6
		Dark_Blue                               272        #0D325B
		Dark_Green                              288        #184632
		Dark_Brown                              308        #352100
		Maersk_Blue                             313        #54A9C8
		Dark_Red                                320        #720E0F
		Dark_Azure                              321        #1498D7
		Medium_Azure                            322        #3EC2DD
		Light_Aqua                              323        #BDDCD8
		Yellowish_Green                         326        #DFEEA5
		Olive_Green                             330        #9B9A5A
		Sand_Red                                335        #D67572
		Medium_Dark_Pink                        351        #F785B1
		Earth_Orange                            366        #FA9C1C
		Sand_Purple                             373        #845E84
		Sand_Green                              378        #A0BCAC
		Sand_Blue                               379        #597184
		Fabuland_Brown                          450        #B67B50
		Medium_Orange                           462        #FFA70B
		Dark_Orange                             484        #A95500
		Very_Light_Gray                         503        #E6E3DA
		Trans_Clear                             47         #FCFCFC
		Trans_Black                             40         #635F52
		Trans_Red                               36         #C91A09
		Trans_Neon_Orange                       38         #FF800D
		Trans_Orange                            57         #F08F1C
		Trans_Neon_Yellow                       54         #DAB000
		Trans_Yellow                            46         #F5CD2F
		Trans_Neon_Green                        42         #C0FF00
		Trans_Bright_Green                      35         #56E646
		Trans_Green                             34         #237841
		Trans_Dark_Blue                         33         #0020A0
		Trans_Medium_Blue                       41         #559AB7
		Trans_Light_Blue                        43         #AEE9EF
		Trans_Very_Light_Blue                   39         #C1DFF0
		Trans_Light_Purple                      44         #96709F
		Trans_Purple                            52         #A5A5CB
		Trans_Dark_Pink                         37         #DF6695
		Trans_Pink                              45         #FC97AC
		Chrome_Gold                             334        #BBA53D
		Chrome_Silver                           383        #E0E0E0
		Chrome_Antique_Brass                    60         #645A4C
		Chrome_Black                            64         #1B2A34
		Chrome_Blue                             61         #6C96BF
		Chrome_Green                            62         #3CB371
		Chrome_Pink                             63         #AA4D8E
		Pearl_White                             183        #F2F3F2
		Pearl_Very_Light_Gray                   150        #BBBDBC
		Pearl_Light_Gray                        135        #9CA3A8
		Flat_Silver                             179        #898788
		Pearl_Dark_Gray                         148        #575857
		Metal_Blue                              137        #5677BA
		Pearl_Light_Gold                        142        #DCBE61
		Pearl_Gold                              297        #CC9C2B
		Flat_Dark_Gold                          178        #B4883E
		Copper                                  134        #964A27
		Metallic_Silver                         80         #A5A9B4
		Metallic_Green                          81         #899B5F
		Metallic_Gold                           82         #DBAC34
		Metallic_Black                          83         #1A2831
		Metallic_Dark_Gray                      87         #6D6E5C
		Milky_White                             79         #FFFFFF
		Glow_In_Dark_Opaque                     21         #E0FFB0
		Glow_In_Dark_Trans                      294        #BDC6AD
		Glitter_Trans_Dark_Pink                 114        #DF6695
		Glitter_Trans_Clear                     117        #FFFFFF
		Glitter_Trans_Purple                    129        #640061
		Speckle_Black_Silver                    132        #000000
		Speckle_Black_Gold                      133        #000000
		Speckle_Black_Copper                    75         #000000
		Speckle_Dark_Bluish_Gray_Silver         76         #635F61
		Rubber_Yellow                           65         #F5CD2F
		Rubber_Trans_Yellow                     66         #CAB000
		Rubber_Trans_Clear                      67         #FFFFFF
		Rubber_Black                            256        #212121
		Rubber_Blue                             273        #0033B2
		Rubber_Red                              324        #C40026
		Rubber_Orange                           350        #D06610
		Rubber_Light_Gray                       375        #C1C2C1
		Rubber_Dark_Blue                        406        #001D68
		Rubber_Purple                           449        #81007B
		Rubber_Lime                             490        #D7F000
		Rubber_Light_Bluish_Gra                 496        #A3A2A4
		Rubber_Flat_Silver                      504        #898788
		Rubber_White                            511        #FAFAFA
		Main_Colour                             16         #7F7F7F
		Edge_Colour                             24         #7F7F7F
		Trans_Black_IR_Lens                     32         #000000
		Magnet                                  493        #656761
		Electric_Contact_Alloy                  494        #D0D0D0
		Electric_Contact_Copper                 495        #AE7A59
		COLORS
	fi
}

l2cu_optimize () {
	blender						\
		--background			\
		--python "${optimize}"	\
								"${export_file_3ds}" > /dev/null 2>&1
}

l2cu_export () {
	frobulator.inf "Exporting" "[ '${model_file}' ]"
	frobulator.inf "Format"    "[ '${export_name}' ]"
	echo

	frobulator.inf "Output" "[ '${export_file}' ]"
	echo

	leocad										\
		"-${export_option}" "${export_file}" 	\
												"${model_path}" > /dev/null 2>&1

	wait
}

l2cu_render () {
	frobulator.inf "Rendering" "[ '${model_name}' ]"
	frobulator.inf "View"      "[ '${view[coordinates]}' ]"
	echo

	frobulator.inf "Output" "[ '${render_file}' ]"
	echo


	model_path="${1}"
	coordinates="${2}"

	height="4096"
	width="4096"

	extension="png"

	leocad																		\
		--height "${height}"													\
		--width "${width}"														\
		--image "${model_name}-${view[$coordinates]}.${extension}"				\
		--camera-angles ${latitude[$coordinates]} ${longitude[$coordinates]}	\
		--shading "${shading}"													\
		--line-width "${line_width}" 											\
																				"${model_path}" > /dev/null 2>&1

	wait
}

l2cu_export_size () {
	# verify export file size

	block_size=1024

	# get model size in bytes

	export_size=$(find -type f "${export_directory}${export_file}" | du -B "${block_size}" | cut -f 1)

	# set model size threshold in bytes : 25 * 1024

	export_size_threshold="25600"

	# if lesser than threshold

	if [[ "${export_size}" -le "${export_size_threshold}" ]]
	then
		frobulator.scs "File size threshold not exceeded" "[ ${export_size} ]"
		echo
	fi

	# if greater than threshold

	if [[ "${export_size}" -gt "${export_size_threshold}" ]]
	then
		frobulator.err "File size threshold exceeded" "[ ${export_size} ]"
		echo

		frobulator.wrn "Model file size is above recommended threshold of ${export_size_threshold}B"
		frobulator.wrn "You may experience higher than average loading times."
		echo
	fi
}

parse_input () {
	while true
	do
		read input

		if [ -z "${input}" ]
		then
			frobulator.wrn "Input cannot be empty."
			frobulator.wrn "Try again."
			echo
		else
			break
		fi
	done
}

parse_colors () {
	parse_input

	# set to lowercase for input match

	color_input="${input,,}"

	while IFS=$' '
	read -r ldraw_color_name ldraw_color_value ldraw_color_hex_value
	do
		# color input entries cleanup

		# color name

		# remove underscores from name

		ldraw_color_name="${ldraw_color_name//_/ }"

		# set name to lowercase for input match

		ldraw_color_name="${ldraw_color_name,,}"

		# reattribute input variable to lowercase name value

		ldraw_color_name="${ldraw_color_name}"

		# color hex value

		# remove pound from value

		ldraw_color_hex_value="${ldraw_color_hex_value//#/}"

		# set value to lowercase for input match

		ldraw_color_hex_value="${ldraw_color_hex_value,,}"

		# attribute input variable to lowercase name value

		ldraw_color_hex_value="${ldraw_color_hex_value}"

		if [[ "${color_input}" == "${ldraw_color_name}"      ]] || \
		   [[ "${color_input}" == "${ldraw_color_value}"     ]] || \
		   [[ "${color_input}" == "${ldraw_color_hex_value}" ]]
		then
			# confirmation

			frobulator.fwd "Confirming input value:"
			echo
			frobulator.inf "Color name "              "[ ${ldraw_color_name} ]"
			frobulator.inf "Color value "             "[ ${ldraw_color_value} ]"
			frobulator.inf "Color hexadecimal value " "[ ${ldraw_color_hex_value} ]"
			echo

			return "${ldraw_color_value}"
		fi

	done < "${colors}"

	frobulator.err "No color match for input" "[ '${input}' ]"
	echo

	frobulator.fwd "Exiting..."
	echo

	exit 1
}

parse_parts () {
	parse_input

	part_input="${input}"

	return "${part_input}"
}

parse_modification () {
	if [ "${modify_option}" = "color" ]
	then
		frobulator.ipt "Enter color to modify" "[ name / number / hexadecimal ]"

		parse_colors

		# $? returning wrong arbitrary value

		old_color="${ldraw_color_value}"

		frobulator.ipt "Enter color to set" "[ name / number / hexadecimal ]"

		parse_colors

		# $? returning wrong arbitrary value

		new_color="${ldraw_color_value}"
	fi

	if [ "${modify_option}" = "part" ]
	then
		frobulator.ipt "Enter part to modify" "[ number ]"

		parse_parts

		# $? returning wrong arbitrary value

		old_part="${part_input}"

		frobulator.ipt "Enter part to set" "[ number ]"

		parse_parts

		# $? returning wrong arbitrary value

		new_part="${part_input}"
	fi

	if [ "${modify_option}" = "bind" ]
	then
		frobulator.ipt "Enter part to modify" "[ number ]"

		parse_parts

		# $? returning wrong arbitrary value

		part_selection="${part_input}"

		frobulator.ipt "Enter color to modify" "[ name / number / hexadecimal ]"

		parse_colors

		# $? returning wrong arbitrary value

		old_color="${ldraw_color_value}"

		frobulator.ipt "Enter color to set" "[ name / number / hexadecimal ]"

		parse_colors

		# $? returning wrong arbitrary value for $new_color

		new_color="${ldraw_color_value}"
	fi
}

l2cu_write () {
	# manage model file overwrite

	if [ "${overwrite_option}" = "overwrite" ]
	then
		frobulator.wrn "Writing to model file" "[ overwrite ]"
		echo

		frobulator.inf "Writing" "[ ${model_file} ]"
		echo

		mv "${model_buffer}" "${model_buffer%.tmp}"
	fi

	if [ -z "${overwrite_option}" ]
	then
		frobulator.ipt "Write to model file?"
		echo

		read reply

		if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
		then
			frobulator.inf "Writing to model file" "[ overwrite ]"
			echo

			frobulator.inf "Writing" "[ ${model_file} ]"
			echo

			mv "${model_buffer}" "${model_buffer%.tmp}"

		else
			frobulator.inf "Writing to model file copy."
			echo

			frobulator.fwd "Writing..."
			echo

			mv "${model_buffer}" "${model_buffer%.tmp}-modified-${stamp}.${extension}"
		fi
	fi
}

# requirements ////////////////////////////////////////////////////////////////

list=(
	leocad
)

if [ "${option}" = "3ds" ]
then
	list+=(
		blender
	)
fi

if [ "${option}" = "get" ]
then
	list+=(
		zip
		unzip
	)
fi

frobulator.require ${list[@]}

list=()

# generate necessary process files

l2cu_prepare

# confirmation ////////////////////////////////////////////////////////////////

frobulator.msg "Extension option" "[ '${extension_option}' ]"
frobulator.msg "Option"           "[ '${option}' ]"
echo

frobulator.wait 1

if [ "${option}" = "render" ]
then
	frobulator.inf "Render option" "[ '${render_option}' ]"
	echo
fi

if [ "${option}" = "export" ]
then
	frobulator.inf "Export parameter" "[ '${export_name}' ]"
	echo
fi

if [ "${option}" = "overwrite" ]
then
	frobulator.wrn "WARNING:"
	frobulator.wrn "Overwrite option selected:"
	frobulator.wrn "Model modifications will be written to file directly!"
	echo
fi

frobulator.fwd "Proceeding..."
echo

# export //////////////////////////////////////////////////////////////////////

if [ "${option}" = "export" ]
then
	for extension in ${extensions_list[@]}
	do
		models_list=( $(find ${directory} -type f -iname "*.${extension}") )

		for model_path in ${models_list[@]}
		do
			# set IFS

			IFS=' '

			# get model file name from path

			model_file="${model_path##*/}"

			# strip extension from model file name

			model_name="${model_file%.*}"

			# define export output directory

			# use model directory as root

			export_directory="${model_path%/*}"/exports

			# explicit export file types for optimization

			export_file="${model_name}"."${export_extension}"

			export_file_3ds="${model_name}.3ds"
			export_file_blend="${model_name}.blend"
			export_file_collada="${model_name}.dae"
			export_file_object="${model_name}.obj"
			export_file_material="${model_name}.mtl"
			export_file_archive="${model_name}.zip"

			# export

			mkdir -p "${export_directory}"

			cd "${export_directory}"

			l2cu_export

			# 3ds

			if [[ "${export_option}" = "blender" ]]
			then
				# import 3ds file into blender
				# generate optimized blend file

				frobulator.fwd "Optimizing..."
				echo

				l2cu_optimize

				# cleanup

				rm -rf "${export_file_3ds}"
			fi

			# wavefront

			if [[ "${export_option}" = "wavefront" ]]
			then
				# archive wavefront model components

				zip								\
					"${export_file_archive}"	\
					"${export_file_object}"		\
					"${export_file_material}"

				# cleanup

				rm -rf "${export_file_material}" "${export_file_object}"
			fi

			# verify export size threshold

			l2cu_export_size

			# unset IFS

			IFS=''
		done
	done
fi

# render //////////////////////////////////////////////////////////////////////

if [ "${option}" = "render" ]
then
	for extension in ${extensions_list[@]}
	do
		models_list=( $(find ${directory} -type f -iname "*.${extension}") )

		for model_path in ${models_list[@]}
		do
			# set IFS

			IFS=' '

			# get model file name from path

			model_file="${model_path##*/}"

			# strip extension from model file name

			model_name="${model_file%.*}"

			# define render output directory

			# use model directory as root

			render_directory="${model_path%/*}"/renders

			# use render directory as root

			flat_directory="${model_path%/*}"/renders/flat

			# define coordinate values and labels

			# camera latitude

			latitude=(
				30
				30
				30
				30
			)

			# camera longitude

			longitude=(
				225
				45
				180
				0
			)

			# view labels

			view=(
				"quarter-back"
				"quarter-front"
				"back"
				"front"
			)

			# define camera position presets

			if [[ "${render_preset}" = "full" ]]
			then
				position=(0 1 2 3)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "fixed" ]]
			then
				position=(0 1)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "quarter-back" ]]
			then
				position=(0)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "quarter-front" ]]
			then
				position=(1)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "back" ]]
			then
				position=(2)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "front" ]]
			then
				position=(3)
				shading=full
				line_width=1
			fi

			if [[ "${render_preset}" = "flat" ]]
			then
				position=(1)
				shading=flat
				line_width=0
			fi

			# render

			mkdir -p "${render_directory}"

			cd "${render_directory}"

			if [[ "${render_preset}" = "flat" ]]
			then
				mkdir -p "${flat_directory}"

				cd "${flat_directory}"
			fi

			for coordinates in ${position[@]}
			do
				render_file="${model_name}-${view[$coordinates]}.${extension}"

				l2cu_render "${model_path}" "${coordinates}"
			done

			# post rendering

			if [[ "${render_option}" = "flat" ]]
			then
				# rename renders to designated splash images

				mv												\
					"${model_name}-${view[1]}.${extension}"		\
					"${flat_directory}"/flat."${extension}"
			fi

			# unset IFS

			IFS=''
		done
	done
fi

# modify //////////////////////////////////////////////////////////////////////

if [[ "${option}" = "modify" ]]
then
	# get input

	parse_modification

	# substitution

	IFS=' '

	for extension in ${extensions_list[@]}
	do
		echo $(find ${directory} -type f -iname "*.${extension}") | while read -r model_path
		do
			model_file="${model_path##*/}"
			model_name="${model_file%.*}"

			model_buffer="${model_path}.tmp"

			# parse

			while IFS=''
			read -r line
			do

# modify: lint ////////////////////////////////////////////////////////////////

				if [[ "${modify_option}" = "lint" ]]
				then
					frobulator.inf "Linting model" "[ ${model_file} ]"
					echo

					# substitute windows carriage return for unix newline
					# substitute lines containing empty parsing string
					# substitute multiple whitespace characters to single whitespace
					# substitute author tag to uppercase author tag

					# delete lines beginning with whitespace character
					# delete lines beginning with dot character
					# delete lines containing BACKGROUND meta
					# delete lines containing PIVOT meta
					# delete lines containing HIDDEN meta

					# strip '(' character from model entries
					# strip ')' character from model entries

					sed									\
						-e 's/\r//g' 					\
						-e 's/0 STEP .* *\./0 STEP/g'	\
						-e 's/  */ /g'					\
						-e 's/Author/AUTHOR/g'			\
						-e '/Name/d'					\
						-e '/  *\./d'					\
						-e '/^0\ $/d'					\
						-e '/^1\ $/d'					\
						-e '/^ /d'						\
						-e '/^\./d'						\
						-e '/BACKGROUND/d'				\
						-e '/PIVOT/d'					\
						-e '/HIDDEN/d'					\
						-e 's/(//g'						\
						-e 's/)//g'						\
						-e '/^$/d'						\
														"${model}" > "${model_buffer}"

					break
				fi

				# line breakdown

				# skip header and footer lines containing matching patterns:
				# prevents model file syntax modification

				if [[ "${line}" == *!LEOCAD* ]] || \
				   [[ "${line}" == *FILE*    ]] || \
				   [[ "${line}" == *NOFILE*  ]] || \
				   [[ "${line}" == *AUTHOR*  ]] || \
				   [[ "${line}" == *STEP*    ]]
				then
					echo "${line}" >> "${model_buffer}"

					continue
				fi

				# component is either part or submodel:
				# part:     [number].dat
				# submodel: [name].ldr

				IFS=' '

				read -r flag color x y z a b c d e f g h i component <<< "${line}"

				# split component into part and descriptor

				# set IFS

				IFS='.'

				read part descriptor <<< "${component}"

				# revert IFS

				IFS=' '

# modify: color ///////////////////////////////////////////////////////////////

					# color substitution

					if [[ "${modify_option}" = "color" ]]
					then
						if [[ "${color}" = "${old_color}" ]]
						then
							color="${new_color}"

							frobulator.inf "Model"      "[ ${model_file} ]"
							echo

							frobulator.inf "Modifying " "[ ${old_color} ]"
							frobulator.inf "Setting"    "[ ${new_color} ]"
							echo
						fi
					fi

# modify: part ////////////////////////////////////////////////////////////////

					# part substitution

					if [[ "${modify_option}" = "part" ]]
					then
						if [[ "${part}" = "${old_part}" ]]
						then
							part="${new_part}"

							frobulator.inf "Model"     "[ ${model_file} ]"
							echo

							frobulator.inf "Modifying" "[ ${old_part} ]"
							frobulator.inf "Setting"   "[ ${new_part} ]"
							echo
						fi
					fi

# modify: bind ////////////////////////////////////////////////////////////////

					# bind [ part + color ] color substitution

					if [[ "${modify_option}" = "bind" ]]
					then
						if [[ "${part}" == "${part_selection}" ]]
						then
							if [[ "${color}" = "${old_color}" ]]
							then
								color="${new_color}"

								frobulator.inf "Model"     "[ ${model_file} ]"
								echo

								frobulator.inf "Part"      "[ ${part} ]"
								echo

								frobulator.inf "Modifying" "[ ${old_color} ]"
								frobulator.inf "Setting"   "[ ${new_color} ]"
								echo
							fi
						fi
					fi

# modify: step ////////////////////////////////////////////////////////////////

					# step submodel [ldr] separation

					if [[ "${modify_option}" = "step" ]]
					then
						if [[ "${line}" == *ldr* ]]
						then
							if [[ "${descriptor}" == *ldr* ]]
							then
								flag="0 STEP\n1"
								color="0"
								descriptor="ldr\n0 STEP\n"

								frobulator.inf "Stepping"      "[ ${model_file} ]"
								echo
							fi
						fi
					fi

				# unset IFS

				IFS=''

				# rebuild component from part and descriptor

				component="${part}.${descriptor}"

				# write changes to buffer

				echo "$flag" "${color}" "${x}" "${y}" "${z}" "${a}" "${b}" "${c}" "${d}" "${e}" "${f}" "${g}" "${h}" "${i}" "${component}" >> "${model_buffer}"

			done < "${model_path}" # feed model file into loop for parsing

# modify: overwrite ///////////////////////////////////////////////////////////

			# ammend modifications

			l2cu_write
		done
	done
fi

# get /////////////////////////////////////////////////////////////////////////

if [[ "${option}" = "get" ]]
then
	parts_url="https://www.ldraw.org/library/updates/complete.zip"

	complete_parts_url="https://www.ldraw.org/library/updates/complete.zip"
	update_parts_url="https://ldraw.org/library/unofficial/lcad1903.zip"
	unofficial_parts_url="https://ldraw.org/library/unofficial/ldrawunf.zip"

	if [[ "${get_option}" = "complete" ]]
	then
		parts_url="${complete_parts_url}"
	fi

	if [[ "${get_option}" = "update" ]]
	then
		# workaround until html parsing is complete # TODO #

		parts_url="${complete_parts_url}"
	fi

	if [[ "${get_option}" = "unofficial" ]]
	then
		parts_url="${unofficial_parts_url}"
	fi

	if [ -z "${directory}" ]
	then
		frobulator.ask "Specify download location?"

		echo

		read reply

		if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
		then
			# specify directory location or exit on 'cancel'

			browse=$(frobulator.dialog "Save to") || exit 1

			directory="${browse}"
		else
			directory="${PWD}"

			frobulator.wrn "No directory location specified."
			frobulator.wrn "Downloading into current directory."
			echo
		fi

		get_library
	fi
fi

# list ///////////////////////////////////////////////////////////////////

if [[ "${option}" = "list" ]]
then
	if [ -z "${directory}" ]
	then
		frobulator.wrn "Is the LDraw parts library setup on this system?"

		echo

		read reply

		if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
		then
			# specify directory location or exit on 'cancel'

			browse=$(frobulator.dialog "Load LDraw library") || exit 1

			cd "${browse}" || exit 1

			if [[ "$(basename $(pwd))" == [lL][dD][rR][aA][wW] ]] && [[ -d "parts" ]]
			then
				frobulator.scs "LDraw parts library exists."
				frobulator.scs "Operating within the LDraw parts directory."
				echo
				frobulator.fwd "Continuing..."
				echo

				directory="${browse}"/parts
			else
				frobulator.err "LDraw library directory not recognized: 'parts' directory not found."
			fi
		else
			frobulator.wrn "LDraw parts directory not found."
			frobulator.ask "Specify the LDraw parts library directory location to continue?"

			echo

			read reply

			if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
			then
				# specify directory location or exit on 'cancel'

				browse=$(dialog) || exit 1

				directory="${browse}"/parts
			else
				frobulator.ask "Download the latest LDraw parts library?"

				echo

				read reply

				if [[ "${reply}" = [yY] || "${reply}" = [yY][eE][sS] ]]
				then
					frobulator.fwd "Specify setup location."
					echo

					# specify directory location or exit on 'cancel'

					setup_directory=$(frobulator.dialog) || exit 1

					cd "${setup_directory}" || exit 1

					get_library

					directory="$setup_directory/[lL][dD][rR][aA][wW]/parts"
				else
					frobulator.err "LDraw parts directory not setup on system."
					echo

					frobulator.wrn "The parts.lst file may be needed for some legacy editors to function."
					echo

					frobulator.inf "Visit http://www.ldraw.org to get started."
					frobulator.inf "You can download and extract the LDraw parts library on your system manually."
					frobulator.inf "Restart and run this utility using the 'make-list' option to generate the parts list."
					echo

					frobulator.fwd "Exiting..."
					echo

					exit 1
				fi
			fi
		fi
	fi

	cd "${directory}" || exit 1

	# parts list verification and backup

	if [[ -e [pP][aA][rR][tT][sS].[lL][sS][tT] ]]
	then
		frobulator.wrn "Alternate version of 'parts.lst' file found."
		echo

		frobulator.fwd "Backing up..."
		echo

		mv parts.lst parts.lst.bak
	fi

	# sorting mode verification

	if [[ "$sort_mode" == "description" ]] || [[ "$sort_mode" == "number" ]]
	then
		frobulator.inf "Utility startedusing the $sort_mode option flag."
	else
		frobulator.wrn "No sorting method specified."
		echo

		frobulator.ask "Which sorting method should be used for parsing the parts list?"
		frobulator.ask "[ [dD]escription / [nN]umber ]"
		echo

		read reply
	fi

	if [ -z "${reply}" ]
	then
		exit 1
	else
		# parse parts list

		frobulator.fwd "Processing..."
		echo

		# initialize counter

		count=1

	for extension in ${extensions_list[@]}
	do
		partss_list=( $(find ${directory} -type f -iname "*.${extension}") )

		for part in ${parts_list[@]}
		do
				filename="${part##*/}"
				header="$(head -n 1 "${part}")"
				description="${header:2}"

				if [[ "${description}" == *~Moved* ]]
				then
					: # pass
				else
					if [[ "${description}" == *_* ]]
					then
						printf '%-30s %-s\n' "${filename}" "${description}" >> "._.lst"

					elif [[ "${description}" == *~* ]]
					then
						printf '%-30s %-s\n' "${filename}" "${description}" >> ".~.lst"

					else
						printf '%-30s %-s\n' "${filename}" "${description}" >> parts.lst
					fi

					frobulator.inf "Parts count" "$((count++))\c"
					echo
				fi
			done
		done

		# keep counter visible while looping

		echo

		separator=' '

		# apply sorting method

		for list in "._.lst" ".~.lst" parts.lst
		do
			if [[ "${reply}" = [dD] ]] || [[ "${sort_mode}" == "description" ]]
			then
				sort -b -d -k 2 -t "${separator}" -o "${list}" "${list}"

			elif [[ "${reply}" = [nN] ]] || [[ "${sort_mode}" == "number" ]]
			then
				sort -b -n -k 1 -t "${separator}" -o "${list}" "${list}"
			fi
		done

		# merge

		cat "._.lst" ".~.lst" >> parts.lst

		# cleanup

		rm -rf "._.lst" ".~.lst"
	fi
fi

# complete ////////////////////////////////////////////////////////////////////

frobulator.scs "Done."
echo
